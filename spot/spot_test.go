package spot

import (
	"strings"
	"sync"
	"testing"
	"time"
)

func TestNewSpotIsHumanByDefault(t *testing.T) {
	dx := "W1ABC"
	de := "K1XYZ"
	freq := 14074.5
	mode := "FT8"
	s := NewSpot(dx, de, freq, mode)
	if !s.IsHuman {
		t.Fatalf("NewSpot should mark the spot as human-generated by default")
	}
}

func TestNewSpotBeaconFlag(t *testing.T) {
	s := NewSpot("W1ABC/B", "K1XYZ", 14074.5, "CW")
	if !s.IsBeacon {
		t.Fatalf("NewSpot should mark DX calls ending in /B as beacons")
	}
	nonBeacon := NewSpot("W1ABC", "K1XYZ", 14074.5, "CW")
	if nonBeacon.IsBeacon {
		t.Fatalf("NewSpot should leave IsBeacon false for non-beacon callsigns")
	}
}

func TestRefreshBeaconFlagUsesComment(t *testing.T) {
	s := NewSpot("W1ABC", "K1XYZ", 14074.5, "CW")
	s.Comment = "Heard via NCDXF beacon schedule"
	s.RefreshBeaconFlag()
	if !s.IsBeacon {
		t.Fatalf("RefreshBeaconFlag should set IsBeacon when comment contains NCDXF")
	}

	s.Comment = "strong beacon signal"
	s.RefreshBeaconFlag()
	if !s.IsBeacon {
		t.Fatalf("RefreshBeaconFlag should set IsBeacon when comment contains BEACON")
	}

	s.Comment = "ordinary comment"
	s.RefreshBeaconFlag()
	if s.IsBeacon {
		t.Fatalf("RefreshBeaconFlag should clear IsBeacon when no indicators remain")
	}
}

func TestFormatDXClusterUsesZoneAndGrid(t *testing.T) {
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF-#",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "V",
		DXMetadata: CallMetadata{
			CQZone: 4,
			Grid:   "fn20",
		},
	}

	got := s.FormatDXCluster()
	if !strings.Contains(got, "CW 27 dB CQ 04 FN20") {
		t.Fatalf("expected CQ zone/grid annotation, got %q", got)
	}
	if !strings.HasSuffix(strings.TrimRight(got, " "), "V 0454Z") {
		t.Fatalf("unexpected suffix: %q", got)
	}
}

func TestFormatZoneGridFallbacks(t *testing.T) {
	s := &Spot{
		DXCall:    "N0CALL",
		DECall:    "W1ABC",
		Frequency: 14074.0,
		Mode:      "FT8",
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
	}
	if got := s.formatZoneGridComment(); got != "CQ ??" {
		t.Fatalf("expected fallback CQ ??, got %q", got)
	}
}

func TestFormatGridLabelTruncates(t *testing.T) {
	s := &Spot{
		DXMetadata: CallMetadata{
			CQZone: 5,
			Grid:   "FN20AA",
		},
	}
	if got := s.formatZoneGridComment(); got != "CQ 05 FN20" {
		t.Fatalf("expected truncated grid, got %q", got)
	}
}

func TestFormatDXClusterZeroReport(t *testing.T) {
	s := &Spot{
		DXCall:    "N0CALL",
		DECall:    "W1ABC",
		Frequency: 14074.0,
		Mode:      "FT8",
		Report:    0,
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
	}

	got := s.FormatDXCluster()
	if !strings.Contains(got, "FT8 +0") {
		t.Fatalf("expected 0 dB report to render, got %q", got)
	}
}

func TestFormatDXClusterModeMatrix(t *testing.T) {
	cases := []struct {
		name     string
		mode     string
		report   int
		expected string
	}{
		{"CW positive", "CW", 23, "CW 23 dB"},
		{"RTTY negative", "RTTY", -7, "RTTY -7 dB"},
		{"FT8 positive", "FT8", 12, "FT8 +12"},
		{"FT8 negative", "FT8", -5, "FT8 -5"},
		{"SSB positive", "USB", 8, "USB +8"},
		{"SSB negative", "LSB", -3, "LSB -3"},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			s := &Spot{
				DXCall:    "K1ABC",
				DECall:    "W3LPL",
				Frequency: 7009.5,
				Mode:      tc.mode,
				Report:    tc.report,
				Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
				DXMetadata: CallMetadata{
					CQZone: 5,
					Grid:   "FN20",
				},
			}
			got := s.FormatDXCluster()
			if !strings.Contains(got, tc.expected) {
				t.Fatalf("expected %q to contain %q", got, tc.expected)
			}
			// Time formatting should be HHMMZ.
			if !strings.Contains(got, "0615Z") {
				t.Fatalf("expected time suffix 0615Z, got %q", got)
			}
		})
	}
}

func TestFormatDXClusterFormatOnce(t *testing.T) {
	s := &Spot{
		DXCall:    "K1ABC",
		DECall:    "W3LPL",
		Frequency: 7009.5,
		Mode:      "FT8",
		Report:    -5,
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
		DXMetadata: CallMetadata{
			CQZone: 5,
			Grid:   "FN20",
		},
	}
	first := s.FormatDXCluster()
	// Mutate fields; formatted output should remain identical because it is cached.
	s.Report = 99
	s.Mode = "CW"
	second := s.FormatDXCluster()
	if first != second {
		t.Fatalf("expected cached formatting to remain unchanged; first=%q second=%q", first, second)
	}
}

func TestFormatDXClusterAlignmentNoConfidence(t *testing.T) {
	s := &Spot{
		DXCall:    "K1ABC",
		DECall:    "W3LPL",
		Frequency: 7009.5,
		Mode:      "FT8",
		Report:    -5,
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
		DXMetadata: CallMetadata{
			CQZone: 5,
			Grid:   "FN20",
		},
	}

	got := s.FormatDXCluster()

	const freqStr = "7009.5"
	freqIdx := strings.Index(got, freqStr)
	if freqIdx == -1 {
		t.Fatalf("frequency string missing from output: %q", got)
	}
	if freqIdx+len(freqStr)-1 != 24 {
		t.Fatalf("expected frequency to end at column 24, got %d in %q", freqIdx+len(freqStr)-1, got)
	}

	commentAnchor := "FT8 -5 CQ 05 FN20"
	commentIdx := strings.Index(got, commentAnchor)
	if commentIdx != 40 {
		t.Fatalf("expected comment to start at column 40, got %d in %q", commentIdx, got)
	}

	timeIdx := strings.LastIndex(got, "0615Z")
	if timeIdx != 71 {
		t.Fatalf("expected time to start at column 71, got %d in %q", timeIdx, got)
	}
}

func TestFormatDXClusterAlignmentWithConfidence(t *testing.T) {
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF-#",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "V",
		DXMetadata: CallMetadata{
			CQZone: 4,
			Grid:   "fn20",
		},
	}

	got := s.FormatDXCluster()

	const freqStr = "7014.0"
	freqIdx := strings.Index(got, freqStr)
	if freqIdx == -1 {
		t.Fatalf("frequency string missing from output: %q", got)
	}
	if freqIdx+len(freqStr)-1 != 24 {
		t.Fatalf("expected frequency to end at column 24, got %d in %q", freqIdx+len(freqStr)-1, got)
	}

	commentAnchor := "CW 27 dB CQ 04 FN20"
	commentIdx := strings.Index(got, commentAnchor)
	if commentIdx != 40 {
		t.Fatalf("expected comment to start at column 40, got %d in %q", commentIdx, got)
	}

	timeIdx := strings.LastIndex(got, "0454Z")
	if timeIdx != 71 {
		t.Fatalf("expected time to start at column 71, got %d in %q", timeIdx, got)
	}

	confIdx := strings.LastIndex(got, s.Confidence)
	expectedConfIdx := timeIdx - len(s.Confidence) - 1 // one space between confidence and time
	if confIdx != expectedConfIdx {
		t.Fatalf("expected confidence to end at column %d, got %d in %q", expectedConfIdx, confIdx, got)
	}
}

func BenchmarkFormatDXCluster(b *testing.B) {
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF-#",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "V",
		DXMetadata: CallMetadata{
			CQZone: 4,
			Grid:   "fn20",
		},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		s.formatted = ""
		s.formatOnce = sync.Once{}
		_ = s.FormatDXCluster()
	}
}
