package spot

import (
	"strings"
	"sync"
	"testing"
	"time"
)

func setDXClusterLineLength(t *testing.T, lineLength int) {
	t.Helper()
	prev := CurrentDXClusterLayout()
	if err := SetDXClusterLineLength(lineLength); err != nil {
		t.Fatalf("set line length: %v", err)
	}
	t.Cleanup(func() {
		_ = SetDXClusterLineLength(prev.LineLength)
	})
}

func TestNewSpotIsHumanByDefault(t *testing.T) {
	dx := "W1ABC"
	de := "K1XYZ"
	freq := 14074.5
	mode := "FT8"
	s := NewSpot(dx, de, freq, mode)
	if !s.IsHuman {
		t.Fatalf("NewSpot should mark the spot as human-generated by default")
	}
}

func TestNewSpotBeaconFlag(t *testing.T) {
	s := NewSpot("W1ABC/B", "K1XYZ", 14074.5, "CW")
	if !s.IsBeacon {
		t.Fatalf("NewSpot should mark DX calls ending in /B as beacons")
	}
	nonBeacon := NewSpot("W1ABC", "K1XYZ", 14074.5, "CW")
	if nonBeacon.IsBeacon {
		t.Fatalf("NewSpot should leave IsBeacon false for non-beacon callsigns")
	}
}

func TestNewSpotNormalizesSSBToSideband(t *testing.T) {
	low := NewSpot("W1ABC", "K1XYZ", 7074.0, "SSB")
	if low.Mode != "LSB" {
		t.Fatalf("expected SSB on 40m to normalize to LSB, got %q", low.Mode)
	}

	high := NewSpot("W1ABC", "K1XYZ", 14250.0, "SSB")
	if high.Mode != "USB" {
		t.Fatalf("expected SSB on 20m to normalize to USB, got %q", high.Mode)
	}
}

func TestEnsureNormalizedCollapsesPSKVariants(t *testing.T) {
	s := NewSpot("K1ABC", "W1AW", 14074.0, "PSK31")
	s.ModeNorm = "" // force recompute
	s.EnsureNormalized()
	if s.Mode != "PSK31" {
		t.Fatalf("expected Mode to preserve variant, got %q", s.Mode)
	}
	if s.ModeNorm != "PSK" {
		t.Fatalf("expected ModeNorm to collapse to PSK, got %q", s.ModeNorm)
	}
}

func TestRefreshBeaconFlagUsesComment(t *testing.T) {
	s := NewSpot("W1ABC", "K1XYZ", 14074.5, "CW")
	s.Comment = "Heard via NCDXF beacon schedule"
	s.RefreshBeaconFlag()
	if !s.IsBeacon {
		t.Fatalf("RefreshBeaconFlag should set IsBeacon when comment contains NCDXF")
	}

	s.Comment = "strong beacon signal"
	s.RefreshBeaconFlag()
	if !s.IsBeacon {
		t.Fatalf("RefreshBeaconFlag should set IsBeacon when comment contains BEACON")
	}

	s.Comment = "ordinary comment"
	s.RefreshBeaconFlag()
	if s.IsBeacon {
		t.Fatalf("RefreshBeaconFlag should clear IsBeacon when no indicators remain")
	}
}

func TestFormatDXClusterUsesGridAndConfidence(t *testing.T) {
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF-#",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		HasReport:  true,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "V",
		DXMetadata: CallMetadata{
			CQZone: 4,
			Grid:   "fn20",
		},
	}

	got := s.FormatDXCluster()
	if !strings.Contains(got, "CW 27 dB") {
		t.Fatalf("expected mode/report, got %q", got)
	}
	if strings.Contains(got, "CQ ") {
		t.Fatalf("did not expect CQ/zone label in output, got %q", got)
	}
	if !strings.HasSuffix(strings.TrimRight(got, " "), "FN20 V 0454Z") {
		t.Fatalf("unexpected suffix: %q", got)
	}
}

func TestFormatDXClusterUsesStrippedDECall(t *testing.T) {
	s := &Spot{
		DXCall:         "K1ABC",
		DECall:         "W1XYZ-1",
		DECallStripped: "W1XYZ",
		Frequency:      14074.0,
		Mode:           "FT8",
		Time:           time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
	}

	got := s.FormatDXCluster()
	if strings.Contains(got, "W1XYZ-1") {
		t.Fatalf("expected stripped DE call, got %q", got)
	}
	if !strings.Contains(got, "DX de W1XYZ:") {
		t.Fatalf("expected stripped DE call prefix, got %q", got)
	}
}

func TestFormatDXClusterDXCallDisplayTruncatesAndStripsSuffix(t *testing.T) {
	s := &Spot{
		DXCall:    "HB9/TA1EYE/P",
		DECall:    "OH0M",
		Frequency: 14276.0,
		Mode:      "USB",
		Time:      time.Date(2025, time.December, 26, 15, 37, 0, 0, time.UTC),
	}

	got := s.FormatDXCluster()
	if strings.Contains(got, "/P") {
		t.Fatalf("expected portable suffix to be stripped from output, got %q", got)
	}
	if !strings.Contains(got, "HB9/TA1EYE") {
		t.Fatalf("expected truncated DX call to be present, got %q", got)
	}
	if !strings.Contains(got, "HB9/TA1EYE  USB") {
		t.Fatalf("expected two spaces between DX call and mode, got %q", got)
	}
	if modeIdx := strings.Index(got, "USB"); modeIdx != 39 {
		t.Fatalf("expected mode to start at 0-based index 39 (1-based column 40), got %d in %q", modeIdx, got)
	}
}

func TestFormatCommentTrimsWhitespace(t *testing.T) {
	s := &Spot{
		DXCall:    "N0CALL",
		DECall:    "W1ABC",
		Frequency: 14074.0,
		Mode:      "FT8",
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
		Comment:   "  hello world  ",
	}
	if got := s.formatZoneGridComment(); got != "hello world" {
		t.Fatalf("expected trimmed comment, got %q", got)
	}
}

func TestFormatGridLabelTruncates(t *testing.T) {
	if got := formatGridLabel("FN20AA"); got != "FN20" {
		t.Fatalf("expected grid to truncate to FN20, got %q", got)
	}
}

func TestFormatDXClusterZeroReport(t *testing.T) {
	s := &Spot{
		DXCall:    "N0CALL",
		DECall:    "W1ABC",
		Frequency: 14074.0,
		Mode:      "FT8",
		Report:    0,
		HasReport: true,
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
	}

	got := s.FormatDXCluster()
	if !strings.Contains(got, "FT8 +0 dB") {
		t.Fatalf("expected 0 dB report to render, got %q", got)
	}
}

func TestFormatDXClusterModeMatrix(t *testing.T) {
	cases := []struct {
		name     string
		mode     string
		report   int
		expected string
	}{
		{"CW positive", "CW", 23, "CW 23 dB"},
		{"RTTY negative", "RTTY", -7, "RTTY -7 dB"},
		{"FT8 positive", "FT8", 12, "FT8 +12 dB"},
		{"FT8 negative", "FT8", -5, "FT8 -5 dB"},
		{"SSB positive", "USB", 8, "USB +8 dB"},
		{"SSB negative", "LSB", -3, "LSB -3 dB"},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			s := &Spot{
				DXCall:    "K1ABC",
				DECall:    "W3LPL",
				Frequency: 7009.5,
				Mode:      tc.mode,
				Report:    tc.report,
				HasReport: true,
				Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
				DXMetadata: CallMetadata{
					CQZone: 5,
					Grid:   "FN20",
				},
			}
			got := s.FormatDXCluster()
			if !strings.Contains(got, tc.expected) {
				t.Fatalf("expected %q to contain %q", got, tc.expected)
			}
			// Time formatting should be HHMMZ.
			if !strings.Contains(got, "0615Z") {
				t.Fatalf("expected time suffix 0615Z, got %q", got)
			}
		})
	}
}

func TestFormatDXClusterFormatOnce(t *testing.T) {
	s := &Spot{
		DXCall:    "K1ABC",
		DECall:    "W3LPL",
		Frequency: 7009.5,
		Mode:      "FT8",
		Report:    -5,
		HasReport: true,
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
		DXMetadata: CallMetadata{
			CQZone: 5,
			Grid:   "FN20",
		},
	}
	first := s.FormatDXCluster()
	// Mutate fields; formatted output should remain identical because it is cached.
	s.Report = 99
	s.Mode = "CW"
	second := s.FormatDXCluster()
	if first != second {
		t.Fatalf("expected cached formatting to remain unchanged; first=%q second=%q", first, second)
	}
}

func TestFormatDXClusterAlignmentNoConfidence(t *testing.T) {
	s := &Spot{
		DXCall:    "K1ABC",
		DECall:    "W3LPL",
		Frequency: 7009.5,
		Mode:      "FT8",
		Report:    -5,
		HasReport: true,
		Time:      time.Date(2025, time.November, 22, 6, 15, 0, 0, time.UTC),
		DXMetadata: CallMetadata{
			CQZone: 5,
			Grid:   "FN20",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()

	const freqStr = "7009.5"
	freqIdx := strings.Index(got, freqStr)
	if freqIdx == -1 {
		t.Fatalf("frequency string missing from output: %q", got)
	}
	if freqIdx+len(freqStr)-1 != 24 {
		t.Fatalf("expected frequency to end at 0-based index 24 (1-based column 25), got %d in %q", freqIdx+len(freqStr)-1, got)
	}

	commentAnchor := "FT8 -5 dB"
	commentIdx := strings.Index(got, commentAnchor)
	if commentIdx != 39 {
		t.Fatalf("expected mode to start at 0-based index 39 (1-based column 40), got %d in %q", commentIdx, got)
	}

	timeIdx := strings.LastIndex(got, "0615Z")
	if timeIdx != layout.TimeColumn-1 {
		t.Fatalf("expected time to start at 0-based index %d (1-based column %d), got %d in %q", layout.TimeColumn-1, layout.TimeColumn, timeIdx, got)
	}

	gridIdx := strings.LastIndex(got, "FN20")
	if gridIdx != layout.GridColumn-1 {
		t.Fatalf("expected grid to start at 0-based index %d (1-based column %d), got %d in %q", layout.GridColumn-1, layout.GridColumn, gridIdx, got)
	}
}

func TestFormatDXClusterAlignmentWithConfidence(t *testing.T) {
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF-#",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		HasReport:  true,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "V",
		DXMetadata: CallMetadata{
			CQZone: 4,
			Grid:   "fn20",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()

	const freqStr = "7014.0"
	freqIdx := strings.Index(got, freqStr)
	if freqIdx == -1 {
		t.Fatalf("frequency string missing from output: %q", got)
	}
	if freqIdx+len(freqStr)-1 != 24 {
		t.Fatalf("expected frequency to end at 0-based index 24 (1-based column 25), got %d in %q", freqIdx+len(freqStr)-1, got)
	}

	commentAnchor := "CW 27 dB"
	commentIdx := strings.Index(got, commentAnchor)
	if commentIdx != 39 {
		t.Fatalf("expected mode to start at 0-based index 39 (1-based column 40), got %d in %q", commentIdx, got)
	}

	timeIdx := strings.LastIndex(got, "0454Z")
	if timeIdx != layout.TimeColumn-1 {
		t.Fatalf("expected time to start at 0-based index %d (1-based column %d), got %d in %q", layout.TimeColumn-1, layout.TimeColumn, timeIdx, got)
	}

	confIdx := strings.LastIndex(got, s.Confidence)
	expectedConfIdx := layout.ConfidenceColumn - 1
	if confIdx != expectedConfIdx {
		t.Fatalf("expected confidence to start at 0-based index %d (1-based column %d), got %d in %q", expectedConfIdx, layout.ConfidenceColumn, confIdx, got)
	}

	gridIdx := strings.LastIndex(got, "FN20")
	if gridIdx != layout.GridColumn-1 {
		t.Fatalf("expected grid to start at 0-based index %d (1-based column %d), got %d in %q", layout.GridColumn-1, layout.GridColumn, gridIdx, got)
	}
}

func TestFormatDXClusterRespectsLineLength(t *testing.T) {
	setDXClusterLineLength(t, 70)
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		HasReport:  true,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "V",
		DXMetadata: CallMetadata{
			Grid: "FN20",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()
	if len(got) != layout.LineLength {
		t.Fatalf("expected length %d, got %d: %q", layout.LineLength, len(got), got)
	}
	if got[layout.GlyphColumn-1] != ' ' {
		t.Fatalf("expected glyph column %d to be a space, got %q", layout.GlyphColumn, got[layout.GlyphColumn-1])
	}
	gridIdx := strings.LastIndex(got, "FN20")
	if gridIdx != layout.GridColumn-1 {
		t.Fatalf("expected grid to start at 0-based index %d (1-based column %d), got %d in %q", layout.GridColumn-1, layout.GridColumn, gridIdx, got)
	}
	confIdx := strings.LastIndex(got, "V")
	if confIdx != layout.ConfidenceColumn-1 {
		t.Fatalf("expected confidence to start at 0-based index %d (1-based column %d), got %d in %q", layout.ConfidenceColumn-1, layout.ConfidenceColumn, confIdx, got)
	}
	timeIdx := strings.LastIndex(got, "0454Z")
	if timeIdx != layout.TimeColumn-1 {
		t.Fatalf("expected time to start at 0-based index %d (1-based column %d), got %d in %q", layout.TimeColumn-1, layout.TimeColumn, timeIdx, got)
	}
}

func TestFormatDXClusterNonASCIIConfidenceReplaced(t *testing.T) {
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		HasReport:  true,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "\u2605",
		DXMetadata: CallMetadata{
			Grid: "fn20",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()
	if len(got) != layout.LineLength {
		t.Fatalf("expected FormatDXCluster to return %d chars (CRLF added by telnet), got %d: %q", layout.LineLength, len(got), got)
	}
	confIdx := layout.ConfidenceColumn - 1
	if got[confIdx] != '?' {
		t.Fatalf("expected non-ASCII confidence to be replaced with '?', got %q in %q", got[confIdx], got)
	}
}

func TestFormatDXClusterTruncatesCommentAndKeepsTailFixed(t *testing.T) {
	s := &Spot{
		DXCall:     "R4WD",
		DECall:     "N0YY",
		Frequency:  28014.2,
		Mode:       "CW",
		Report:     0,
		HasReport:  false,
		Time:       time.Date(2025, time.November, 22, 3, 4, 0, 0, time.UTC),
		Confidence: "S",
		Comment:    "ARRL 10 Meter Contest IO67 some extra text that should be truncated before the tail",
		DXMetadata: CallMetadata{
			Grid: "EM96",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()
	if len(got) != layout.LineLength {
		t.Fatalf("expected FormatDXCluster to return %d chars (CRLF added by telnet), got %d: %q", layout.LineLength, len(got), got)
	}

	modeIdx := strings.Index(got, "CW")
	if modeIdx != 39 {
		t.Fatalf("expected mode to start at 0-based index 39 (1-based column 40), got %d in %q", modeIdx, got)
	}

	if strings.Contains(got, " dB") {
		t.Fatalf("did not expect a report to render when HasReport=false, got %q", got)
	}
	if !strings.Contains(got, "ARRL 10 Meter") {
		t.Fatalf("expected comment to appear in output, got %q", got)
	}

	gridIdx := strings.LastIndex(got, "EM96")
	if gridIdx != layout.GridColumn-1 {
		t.Fatalf("expected grid to start at 0-based index %d (1-based column %d), got %d in %q", layout.GridColumn-1, layout.GridColumn, gridIdx, got)
	}

	confIdx := strings.LastIndex(got, "S")
	if confIdx != layout.ConfidenceColumn-1 {
		t.Fatalf("expected confidence to start at 0-based index %d (1-based column %d), got %d in %q", layout.ConfidenceColumn-1, layout.ConfidenceColumn, confIdx, got)
	}

	timeIdx := strings.LastIndex(got, "0304Z")
	if timeIdx != layout.TimeColumn-1 {
		t.Fatalf("expected time to start at 0-based index %d (1-based column %d), got %d in %q", layout.TimeColumn-1, layout.TimeColumn, timeIdx, got)
	}
}

func TestFormatDXClusterSanitizesTabsInComment(t *testing.T) {
	s := &Spot{
		DXCall:     "R4WD",
		DECall:     "N0YY",
		Frequency:  28014.2,
		Mode:       "CW",
		Report:     0,
		HasReport:  false,
		Time:       time.Date(2025, time.November, 22, 3, 4, 0, 0, time.UTC),
		Confidence: "S",
		Comment:    "ARRL\t10 Meter\tContest IO67\ttext",
		DXMetadata: CallMetadata{
			Grid: "EM96",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()
	if len(got) != layout.LineLength {
		t.Fatalf("expected FormatDXCluster to return %d chars (CRLF added by telnet), got %d: %q", layout.LineLength, len(got), got)
	}
	if strings.Contains(got, "\t") {
		t.Fatalf("expected tab characters to be sanitized from output, got %q", got)
	}

	gridIdx := strings.LastIndex(got, "EM96")
	if gridIdx != layout.GridColumn-1 {
		t.Fatalf("expected grid to start at 0-based index %d (1-based column %d), got %d in %q", layout.GridColumn-1, layout.GridColumn, gridIdx, got)
	}
	confIdx := strings.LastIndex(got, "S")
	if confIdx != layout.ConfidenceColumn-1 {
		t.Fatalf("expected confidence to start at 0-based index %d (1-based column %d), got %d in %q", layout.ConfidenceColumn-1, layout.ConfidenceColumn, confIdx, got)
	}
	timeIdx := strings.LastIndex(got, "0304Z")
	if timeIdx != layout.TimeColumn-1 {
		t.Fatalf("expected time to start at 0-based index %d (1-based column %d), got %d in %q", layout.TimeColumn-1, layout.TimeColumn, timeIdx, got)
	}
}

func TestFormatDXClusterSanitizesNewlinesInComment(t *testing.T) {
	s := &Spot{
		DXCall:     "R4WD",
		DECall:     "N0YY",
		Frequency:  28014.2,
		Mode:       "CW",
		Report:     0,
		HasReport:  false,
		Time:       time.Date(2025, time.November, 22, 3, 4, 0, 0, time.UTC),
		Confidence: "S",
		Comment:    "ARRL 10 Meter\nContest\rIO67",
		DXMetadata: CallMetadata{
			Grid: "EM96",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()
	if len(got) != layout.LineLength {
		t.Fatalf("expected FormatDXCluster to return %d chars (CRLF added by telnet), got %d: %q", layout.LineLength, len(got), got)
	}
	if strings.ContainsAny(got, "\r\n") {
		t.Fatalf("expected newline characters to be sanitized from output, got %q", got)
	}

	gridIdx := strings.LastIndex(got, "EM96")
	if gridIdx != layout.GridColumn-1 {
		t.Fatalf("expected grid to start at 0-based index %d (1-based column %d), got %d in %q", layout.GridColumn-1, layout.GridColumn, gridIdx, got)
	}
	confIdx := strings.LastIndex(got, "S")
	if confIdx != layout.ConfidenceColumn-1 {
		t.Fatalf("expected confidence to start at 0-based index %d (1-based column %d), got %d in %q", layout.ConfidenceColumn-1, layout.ConfidenceColumn, confIdx, got)
	}
	timeIdx := strings.LastIndex(got, "0304Z")
	if timeIdx != layout.TimeColumn-1 {
		t.Fatalf("expected time to start at 0-based index %d (1-based column %d), got %d in %q", layout.TimeColumn-1, layout.TimeColumn, timeIdx, got)
	}
}

func TestFormatDXClusterLeavesSpaceBeforeGrid(t *testing.T) {
	s := &Spot{
		DXCall:     "ON4WIY",
		DECall:     "S50TA",
		Frequency:  144336.0,
		Mode:       "MSK144",
		Report:     6,
		HasReport:  true,
		Time:       time.Date(2025, time.November, 22, 21, 40, 0, 0, time.UTC),
		Confidence: "S",
		Comment:    "ABCDEFGHIJKLMN", // chosen to exactly fill the comment area
		DXMetadata: CallMetadata{
			Grid: "DM04",
		},
	}

	got := s.FormatDXCluster()
	layout := CurrentDXClusterLayout()
	if len(got) != layout.LineLength {
		t.Fatalf("expected FormatDXCluster to return %d chars (CRLF added by telnet), got %d: %q", layout.LineLength, len(got), got)
	}
	gridIdx := strings.LastIndex(got, "DM04")
	if gridIdx != layout.GridColumn-1 {
		t.Fatalf("expected grid to start at 0-based index %d (1-based column %d), got %d in %q", layout.GridColumn-1, layout.GridColumn, gridIdx, got)
	}
	if got[gridIdx-1] != ' ' {
		t.Fatalf("expected at least one space between comment and grid (byte %d), got %q in %q", gridIdx-1, got[gridIdx-1], got)
	}
}

func BenchmarkFormatDXCluster(b *testing.B) {
	s := &Spot{
		DXCall:     "KE0UI",
		DECall:     "W2NAF-#",
		Frequency:  7014.0,
		Mode:       "CW",
		Report:     27,
		HasReport:  true,
		Time:       time.Date(2025, time.November, 22, 4, 54, 0, 0, time.UTC),
		Confidence: "V",
		DXMetadata: CallMetadata{
			CQZone: 4,
			Grid:   "fn20",
		},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		s.formatted = ""
		s.formatOnce = sync.Once{}
		_ = s.FormatDXCluster()
	}
}
